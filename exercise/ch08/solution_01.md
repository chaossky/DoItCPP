### 문제 1 클래스 객체 곱하기 연산자 오버로딩
몬스터 A, B, C를 진화하기 위해서 A, B, C를 곱하는 연산을 오버로딩해 보세요. A×B, A×C, B×A, B×C, C×A, C×B 각각 다른 형태로 진화하도록 만들어 보겠습니다. A×B와 B×A는 다른 형태의 진화입니다. 몬스터 사이에는 상생이 있어서 상생이 좋은 경우는 능력치가 더욱 향상되고, 상생이 좋지 않은 경우에는 진화에 실패합니다. 상생 관계는 다음 표와 같습니다.

||A|B|C|
|:---:|:---:|:---:|:---:|
|A|X2|X3|실패|
|B|X5|X2|실패|
|C|실패|X4|X2|

소스 코드로 구현할 때 한 가지 요구 사항이 있습니다. 흡수한 제물의 능력치를 빼앗는 것뿐만 아니라, 제물의 특수 능력을 사용할 수 있어야 합니다. 그런데 몬스터의 특수 능력은 몬스터 A, B, C가 상속받은 부모의 함수를 오버라이딩한 함수입니다. 제물을 흡수한 몬스터는 자신의 특수 능력과 제물의 특수 능력을 모두 사용 가능합니다. 제물은 컴포지션이나 어그리게이션으로 표현합니다.
<br/><br/>

---

#### 모범 답안
##### 답안
```cpp
```
##### 설명
C++는 고수준의 언어 이면서도 메모리 직접 접근이 가능하여 높은 성능을 얻을 수 있는 프로그래밍 언어 입니다. 다양한 특징이 있지만 언어를 창시한 스트롭스트룹
은 자신의 논문에서 밝힌 주요 특징은 다음과 같습니다.
<ul>
  <li><b>낮은 수준 액세스와 추상화</b> C++는 C 언어처럼 시스템에 직접 접근할 수 있고, Simula처럼 데이터를 추상화하여 접근할 수 있도록 했습니다.</li>
  <li><b>유용한 도구</b> C++는 범용 언어로 애플리케이션 개발은 물론, 시스템에 접근하여 하드웨어를 직접 다룰 수도 있습니다.</li>
  <li><b>시점</b> C++는 객체지향 프로그래밍을 지원하는 첫 번째 언어는 아니었지만, 언어 특유의 범용성 덕분에 출시부터 실제 문제를 해결하는 유용한 도구로 사용되었습니다.</li>
  <li><b>비독점</b> AT&T 벨 연구소는 C++ 개발 이후 소유권을 독점하지 않았습니다. C++가 외부에서 개발되는 것을 장려하고 1989년 이후에는 모든 권리를 표준 기구로 이양했습니다.</li>
  <li><b>안정성</b> 초기 배포부터 C 언어와 호환성, 안정성을 확보했으며 이후에도 높은 호환성과 안정성을 유지하기 위해 표준화 과정을 충실하게 수행했습니다.</li>
  <li><b>발전</b> 예외 처리, 템플릿, STL 같은 새로운 기능이 C++ 전반에 걸쳐 계속 추가되었습니다.</li>
</ul>

_위 답안이 아니더라도 C++언어의 특징을 잘 설명한 답도 괜찮습니다._

[문제로 돌아 가기](README.md "문제로 돌아 가기")
